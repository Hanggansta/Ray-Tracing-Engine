!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
AABB	include/geometry/aabb.hh	/^		AABB(){}$/;"	f	class:AABB	access:public	signature:()
AABB	include/geometry/aabb.hh	/^		AABB(const Vec& v1, const Vec& v2):$/;"	f	class:AABB	access:public	signature:(const Vec& v1, const Vec& v2)
AABB	include/geometry/aabb.hh	/^class AABB {$/;"	c
AABB::AABB	include/geometry/aabb.hh	/^		AABB(){}$/;"	f	class:AABB	access:public	signature:()
AABB::AABB	include/geometry/aabb.hh	/^		AABB(const Vec& v1, const Vec& v2):$/;"	f	class:AABB	access:public	signature:(const Vec& v1, const Vec& v2)
AABB::contain	include/geometry/aabb.hh	/^		bool contain(const Vec& p) const$/;"	f	class:AABB	access:public	signature:(const Vec& p) const
AABB::empty	include/geometry/aabb.hh	/^		bool empty()$/;"	f	class:AABB	access:public	signature:()
AABB::intersect	include/geometry/aabb.hh	/^		bool intersect(const Ray& ray, real_t &mind, real_t &maxd) {$/;"	f	class:AABB	access:public	signature:(const Ray& ray, real_t &mind, real_t &maxd)
AABB::max	include/geometry/aabb.hh	/^			max = -Vec::max();$/;"	m	class:AABB	access:private
AABB::min	include/geometry/aabb.hh	/^		Vec min = Vec::max(),$/;"	m	class:AABB	access:private
AABB::set	include/geometry/aabb.hh	/^		void set(const Vec& vmin, const Vec& vmax)$/;"	f	class:AABB	access:public	signature:(const Vec& vmin, const Vec& vmax)
AABB::size	include/geometry/aabb.hh	/^		Vec size() const$/;"	f	class:AABB	access:public	signature:() const
AABB::update	include/geometry/aabb.hh	/^		void update(const AABB& b) {$/;"	f	class:AABB	access:public	signature:(const AABB& b)
AABB::update	include/geometry/aabb.hh	/^		void update(const Vec& v) {$/;"	f	class:AABB	access:public	signature:(const Vec& v)
AMBIENT_FACTOR	include/common.hh	/^const real_t AMBIENT_FACTOR = 1.0;$/;"	v
BLACK	include/color.hh	/^		static const Color WHITE, BLACK;$/;"	m	class:Color	access:public
CC	Makefile	/^CC = g++$/;"	m
COLOR_BLUE	include/utils.hh	19;"	d
COLOR_CYAN	include/utils.hh	21;"	d
COLOR_GREEN	include/utils.hh	17;"	d
COLOR_MAGENTA	include/utils.hh	20;"	d
COLOR_RED	include/utils.hh	16;"	d
COLOR_RESET	include/utils.hh	22;"	d
COLOR_YELLOW	include/utils.hh	18;"	d
CVRender	include/opencv.hh	/^		CVRender(const Geometry &m_g);$/;"	p	class:CVRender	access:public	signature:(const Geometry &m_g)
CVRender	include/opencv.hh	/^class CVRender: public RenderBase {$/;"	c	inherits:RenderBase
CVRender	opencv.cc	/^CVRender::CVRender(const Geometry &m_g):$/;"	f	class:CVRender	signature:(const Geometry &m_g)
CVRender::CVRender	include/opencv.hh	/^		CVRender(const Geometry &m_g);$/;"	p	class:CVRender	access:public	signature:(const Geometry &m_g)
CVRender::CVRender	opencv.cc	/^CVRender::CVRender(const Geometry &m_g):$/;"	f	class:CVRender	signature:(const Geometry &m_g)
CVRender::_write	include/opencv.hh	/^		void _write(int x, int y, const Color& c);$/;"	p	class:CVRender	access:protected	signature:(int x, int y, const Color& c)
CVRender::_write	opencv.cc	/^void CVRender::_write(int x, int y, const Color& c) {$/;"	f	class:CVRender	signature:(int x, int y, const Color& c)
CVRender::finish	include/opencv.hh	/^		void finish();$/;"	p	class:CVRender	access:public	signature:()
CVRender::finish	opencv.cc	/^void CVRender::finish() {$/;"	f	class:CVRender	signature:()
CVRender::img	include/opencv.hh	/^	cv::Mat img;$/;"	m	class:CVRender	access:private
CVRender::~CVRender	include/opencv.hh	/^		~CVRender() {}$/;"	f	class:CVRender	access:public	signature:()
CXXFLAGS	Makefile	/^CXXFLAGS = $(INCLUDE_DIR) $(DEFINES) -std=c++11 $(OPTFLAGS)$/;"	m
C_EPS	include/color.hh	/^		static constexpr real_t C_EPS = 1e-4;$/;"	m	class:Color	access:public
Color	include/color.hh	/^		Color(real_t r = 0, real_t g = 0, real_t b = 0):$/;"	f	class:Color	access:public	signature:(real_t r = 0, real_t g = 0, real_t b = 0)
Color	include/color.hh	/^class Color: public Vector {$/;"	c	inherits:Vector
Color::BLACK	include/color.hh	/^		static const Color WHITE, BLACK;$/;"	m	class:Color	access:public
Color::C_EPS	include/color.hh	/^		static constexpr real_t C_EPS = 1e-4;$/;"	m	class:Color	access:public
Color::Color	include/color.hh	/^		Color(real_t r = 0, real_t g = 0, real_t b = 0):$/;"	f	class:Color	access:public	signature:(real_t r = 0, real_t g = 0, real_t b = 0)
Color::WHITE	include/color.hh	/^		static const Color WHITE, BLACK;$/;"	m	class:Color	access:public
Color::black	include/color.hh	/^		bool black() const$/;"	f	class:Color	access:public	signature:() const
Color::check	include/color.hh	/^		void check() const {$/;"	f	class:Color	access:public	signature:() const
DEFAULT_TRACING_WEIGHT_THRESHOLD	include/common.hh	/^const real_t DEFAULT_TRACING_WEIGHT_THRESHOLD = EPS;$/;"	v
DEFINES	Makefile	/^DEFINES = -DDEBUG$/;"	m
DEPFILES	Makefile	/^DEPFILES = $(OBJS:.o=.d)$/;"	m
EPS	include/common.hh	/^const real_t EPS = 1e-6;$/;"	v
Geometry	include/render.hh	/^		Geometry(int m_w = 0, int m_h = 0):$/;"	f	class:Geometry	access:public	signature:(int m_w = 0, int m_h = 0)
Geometry	include/render.hh	/^class Geometry {$/;"	c
Geometry::Geometry	include/render.hh	/^		Geometry(int m_w = 0, int m_h = 0):$/;"	f	class:Geometry	access:public	signature:(int m_w = 0, int m_h = 0)
Geometry::area	include/render.hh	/^		inline int area() const {$/;"	f	class:Geometry	access:public	signature:() const
Geometry::contain	include/render.hh	/^		inline bool contain(int x, int y)$/;"	f	class:Geometry	access:public	signature:(int x, int y)
Geometry::h	include/render.hh	/^		int w, h;$/;"	m	class:Geometry	access:public
Geometry::ratio	include/render.hh	/^		real_t ratio() const {$/;"	f	class:Geometry	access:public	signature:() const
Geometry::w	include/render.hh	/^		int w, h;$/;"	m	class:Geometry	access:public
INCLUDE_DIR	Makefile	/^INCLUDE_DIR = -Iinclude$/;"	m
LDFLAGS	Makefile	/^LDFLAGS = $(shell pkg-config opencv --libs)$/;"	m
Light	include/renderable/light.hh	/^		Light(const Vec& m_src, const Color& col, real_t intense):$/;"	f	class:Light	access:public	signature:(const Vec& m_src, const Color& col, real_t intense)
Light	include/renderable/light.hh	/^class Light : public RenderAble {$/;"	c	inherits:RenderAble
Light::Light	include/renderable/light.hh	/^		Light(const Vec& m_src, const Color& col, real_t intense):$/;"	f	class:Light	access:public	signature:(const Vec& m_src, const Color& col, real_t intense)
Light::color	include/renderable/light.hh	/^		Color color;$/;"	m	class:Light	access:public
Light::get_trace	include/renderable/light.hh	/^		std::shared_ptr<Trace> get_trace(const Ray& ray) const {$/;"	f	class:Light	access:public	signature:(const Ray& ray) const
Light::intensity	include/renderable/light.hh	/^		real_t intensity;$/;"	m	class:Light	access:public
Light::size	include/renderable/light.hh	/^		real_t size = EPS;$/;"	m	class:Light	access:public
Light::src	include/renderable/light.hh	/^		Vec src;$/;"	m	class:Light	access:public
Light::visible_to	include/renderable/light.hh	/^		bool visible_to(const Ray& ray) const$/;"	f	class:Light	access:public	signature:(const Ray& ray) const
LightTrace	include/renderable/light.hh	/^		LightTrace(const Light& m_light, const Ray& m_ray):$/;"	f	class:LightTrace	access:public	signature:(const Light& m_light, const Ray& m_ray)
LightTrace	include/renderable/light.hh	/^class LightTrace : public Trace {$/;"	c	inherits:Trace
LightTrace::LightTrace	include/renderable/light.hh	/^		LightTrace(const Light& m_light, const Ray& m_ray):$/;"	f	class:LightTrace	access:public	signature:(const Light& m_light, const Ray& m_ray)
LightTrace::intersection_dist	include/renderable/light.hh	/^		real_t intersection_dist()$/;"	f	class:LightTrace	access:public	signature:()
LightTrace::light	include/renderable/light.hh	/^		const Light& light;$/;"	m	class:LightTrace	access:private
LightTrace::normal	include/renderable/light.hh	/^		Vec normal()$/;"	f	class:LightTrace	access:public	signature:()
Matrix	include/matrix.hh	/^		Matrix(const Matrix&) = delete;$/;"	p	class:Matrix	access:public	signature:(const Matrix&)
Matrix	include/matrix.hh	/^		Matrix(int m_w, int m_h):$/;"	f	class:Matrix	access:public	signature:(int m_w, int m_h)
Matrix	include/matrix.hh	/^		Matrix(int m_w, int m_h, T** v)$/;"	f	class:Matrix	access:public	signature:(int m_w, int m_h, T** v)
Matrix	include/matrix.hh	/^class Matrix {$/;"	c
Matrix::Matrix	include/matrix.hh	/^		Matrix(const Matrix&) = delete;$/;"	p	class:Matrix	access:public	signature:(const Matrix&)
Matrix::Matrix	include/matrix.hh	/^		Matrix(int m_w, int m_h):$/;"	f	class:Matrix	access:public	signature:(int m_w, int m_h)
Matrix::Matrix	include/matrix.hh	/^		Matrix(int m_w, int m_h, T** v)$/;"	f	class:Matrix	access:public	signature:(int m_w, int m_h, T** v)
Matrix::h	include/matrix.hh	/^		int w, h;$/;"	m	class:Matrix	access:public
Matrix::operator =	include/matrix.hh	/^		Matrix & operator = (const Matrix &) = delete;$/;"	p	class:Matrix	access:public	signature:(const Matrix &)
Matrix::operator []	include/matrix.hh	/^		T*& operator [] (int i) {$/;"	f	class:Matrix	access:public	signature:(int i)
Matrix::val	include/matrix.hh	/^		T **val;$/;"	m	class:Matrix	access:public
Matrix::w	include/matrix.hh	/^		int w, h;$/;"	m	class:Matrix	access:public
Matrix::~Matrix	include/matrix.hh	/^		~Matrix() {$/;"	f	class:Matrix	access:public	signature:()
MatrixRender	include/matrixrender.hh	/^		MatrixRender(const Geometry &m_g):$/;"	f	class:MatrixRender	access:public	signature:(const Geometry &m_g)
MatrixRender	include/matrixrender.hh	/^class MatrixRender: public RenderBase {$/;"	c	inherits:RenderBase
MatrixRender::MatrixRender	include/matrixrender.hh	/^		MatrixRender(const Geometry &m_g):$/;"	f	class:MatrixRender	access:public	signature:(const Geometry &m_g)
MatrixRender::_write	include/matrixrender.hh	/^		void _write(int x, int y, const Color &c)$/;"	f	class:MatrixRender	access:public	signature:(int x, int y, const Color &c)
MatrixRender::get	include/matrixrender.hh	/^		Color& get(int x, int y)$/;"	f	class:MatrixRender	access:public	signature:(int x, int y)
MatrixRender::mat	include/matrixrender.hh	/^		Matrix<Color>* mat;$/;"	m	class:MatrixRender	access:public
MatrixRender::~MatrixRender	include/matrixrender.hh	/^		~MatrixRender()$/;"	f	class:MatrixRender	access:public	signature:()
OBJS	Makefile	/^OBJS = $(addprefix $(OBJ_DIR)\/,$(ccSOURCES:.cc=.o))$/;"	m
OBJ_DIR	Makefile	/^OBJ_DIR = obj$/;"	m
OPTFLAGS	Makefile	/^OPTFLAGS = -O0 -g$/;"	m
Picture	include/picture.hh	/^		Picture(){ }$/;"	f	class:Picture	access:public	signature:()
Picture	include/picture.hh	/^class Picture {$/;"	c
Picture::Picture	include/picture.hh	/^		Picture(){ }$/;"	f	class:Picture	access:public	signature:()
Picture::add_light	include/picture.hh	/^		void add_light(const Light& light)$/;"	f	class:Picture	access:public	signature:(const Light& light)
Picture::add_obj	include/picture.hh	/^		void add_obj(const std::shared_ptr<RenderAble>& objptr)$/;"	f	class:Picture	access:public	signature:(const std::shared_ptr<RenderAble>& objptr)
Picture::ambient	include/picture.hh	/^		Color ambient;$/;"	m	class:Picture	access:private
Picture::find_first	include/picture.hh	/^		std::shared_ptr<Trace> find_first(const Ray& ray) const;$/;"	p	class:Picture	access:protected	signature:(const Ray& ray) const
Picture::find_first	picture.cc	/^std::shared_ptr<Trace> Picture::find_first(const Ray& ray) const {$/;"	f	class:Picture	signature:(const Ray& ray) const
Picture::init	include/picture.hh	/^		void init();$/;"	p	class:Picture	access:public	signature:()
Picture::init	picture.cc	/^void Picture::init() {$/;"	f	class:Picture	signature:()
Picture::lights	include/picture.hh	/^		std::vector<std::shared_ptr<Light>>  lights;$/;"	m	class:Picture	access:private
Picture::now_max_depth	include/picture.hh	/^		int now_max_depth;$/;"	m	class:Picture	access:private
Picture::now_ray_count	include/picture.hh	/^		int now_ray_count;$/;"	m	class:Picture	access:private
Picture::objs	include/picture.hh	/^		std::vector<std::shared_ptr<RenderAble>> objs;$/;"	m	class:Picture	access:private
Picture::trace	include/picture.hh	/^		Color trace(const Ray& ray, real_t weight = 1, int depth = 0);$/;"	p	class:Picture	access:public	signature:(const Ray& ray, real_t weight = 1, int depth = 0)
Picture::trace	picture.cc	/^Color Picture::trace(const Ray& ray, real_t weight, int depth) {$/;"	f	class:Picture	signature:(const Ray& ray, real_t weight, int depth)
Picture::weight_threshold	include/picture.hh	/^		real_t weight_threshold = DEFAULT_TRACING_WEIGHT_THRESHOLD;$/;"	m	class:Picture	access:public
Picture::~Picture	include/picture.hh	/^		~Picture(){}$/;"	f	class:Picture	access:public	signature:()
Plane	include/geometry/plane.hh	/^		Plane(){}$/;"	f	class:Plane	access:public	signature:()
Plane	include/geometry/plane.hh	/^		Plane(const Vec& m_norm, const Vec& p, bool normalize = false):$/;"	f	class:Plane	access:public	signature:(const Vec& m_norm, const Vec& p, bool normalize = false)
Plane	include/geometry/plane.hh	/^		Plane(const Vec& m_norm, real_t d, bool normalize = false):$/;"	f	class:Plane	access:public	signature:(const Vec& m_norm, real_t d, bool normalize = false)
Plane	include/geometry/plane.hh	/^		Plane(const Vec& v1, const Vec& v2, const Vec& v3) {$/;"	f	class:Plane	access:public	signature:(const Vec& v1, const Vec& v2, const Vec& v3)
Plane	include/geometry/plane.hh	/^		Plane(real_t a, real_t b, real_t c, real_t w) {$/;"	f	class:Plane	access:public	signature:(real_t a, real_t b, real_t c, real_t w)
Plane	include/geometry/plane.hh	/^class Plane {$/;"	c
Plane::Plane	include/geometry/plane.hh	/^		Plane(){}$/;"	f	class:Plane	access:public	signature:()
Plane::Plane	include/geometry/plane.hh	/^		Plane(const Vec& m_norm, const Vec& p, bool normalize = false):$/;"	f	class:Plane	access:public	signature:(const Vec& m_norm, const Vec& p, bool normalize = false)
Plane::Plane	include/geometry/plane.hh	/^		Plane(const Vec& m_norm, real_t d, bool normalize = false):$/;"	f	class:Plane	access:public	signature:(const Vec& m_norm, real_t d, bool normalize = false)
Plane::Plane	include/geometry/plane.hh	/^		Plane(const Vec& v1, const Vec& v2, const Vec& v3) {$/;"	f	class:Plane	access:public	signature:(const Vec& v1, const Vec& v2, const Vec& v3)
Plane::Plane	include/geometry/plane.hh	/^		Plane(real_t a, real_t b, real_t c, real_t w) {$/;"	f	class:Plane	access:public	signature:(real_t a, real_t b, real_t c, real_t w)
Plane::dist	include/geometry/plane.hh	/^		real_t dist(const Vec& p)$/;"	f	class:Plane	access:public	signature:(const Vec& p)
Plane::dist	include/geometry/plane.hh	/^		real_t dist;$/;"	m	class:Plane	access:private
Plane::in_half_space	include/geometry/plane.hh	/^		bool in_half_space(const Vec& p)$/;"	f	class:Plane	access:public	signature:(const Vec& p)
Plane::in_plane	include/geometry/plane.hh	/^		bool in_plane(const Vec& p)$/;"	f	class:Plane	access:public	signature:(const Vec& p)
Plane::norm	include/geometry/plane.hh	/^		Vec norm;$/;"	m	class:Plane	access:private
Plane::parallel	include/geometry/plane.hh	/^		bool parallel(const Ray& ray)$/;"	f	class:Plane	access:public	signature:(const Ray& ray)
Plane::~Plane	include/geometry/plane.hh	/^		virtual ~Plane(){}$/;"	f	class:Plane	access:public	signature:()
PlaneObj	include/renderable/plane.hh	/^class PlaneObj : public RenderAble {$/;"	c	inherits:RenderAble
PlaneObj::plane	include/renderable/plane.hh	/^		Plane plane;$/;"	m	class:PlaneObj	access:private
PlaneObj::visible_to	include/renderable/plane.hh	/^		bool visible_to(const Ray& ray)$/;"	f	class:PlaneObj	access:public	signature:(const Ray& ray)
Ray	include/geometry/ray.hh	/^		Ray(){}$/;"	f	class:Ray	access:public	signature:()
Ray	include/geometry/ray.hh	/^		Ray(const Vec & m_orig, const Vec& m_dir, bool normalize = false):$/;"	f	class:Ray	access:public	signature:(const Vec & m_orig, const Vec& m_dir, bool normalize = false)
Ray	include/geometry/ray.hh	/^class Ray {$/;"	c
Ray::Ray	include/geometry/ray.hh	/^		Ray(){}$/;"	f	class:Ray	access:public	signature:()
Ray::Ray	include/geometry/ray.hh	/^		Ray(const Vec & m_orig, const Vec& m_dir, bool normalize = false):$/;"	f	class:Ray	access:public	signature:(const Vec & m_orig, const Vec& m_dir, bool normalize = false)
Ray::dir	include/geometry/ray.hh	/^		Vec orig, dir;$/;"	m	class:Ray	access:public
Ray::distance	include/geometry/ray.hh	/^		real_t distance(const Vec& p) const$/;"	f	class:Ray	access:public	signature:(const Vec& p) const
Ray::get_dist	include/geometry/ray.hh	/^		Vec get_dist(real_t d) const$/;"	f	class:Ray	access:public	signature:(real_t d) const
Ray::orig	include/geometry/ray.hh	/^		Vec orig, dir;$/;"	m	class:Ray	access:public
Ray::project	include/geometry/ray.hh	/^		Vec project(const Vec& p) const {$/;"	f	class:Ray	access:public	signature:(const Vec& p) const
Ray::sqrdistance	include/geometry/ray.hh	/^		real_t sqrdistance(const Vec& p) const$/;"	f	class:Ray	access:public	signature:(const Vec& p) const
Ray::~Ray	include/geometry/ray.hh	/^		virtual ~Ray(){}$/;"	f	class:Ray	access:public	signature:()
RenderAble	include/renderable/renderable.hh	/^		RenderAble() {}$/;"	f	class:RenderAble	access:public	signature:()
RenderAble	include/renderable/renderable.hh	/^class RenderAble {$/;"	c
RenderAble::RenderAble	include/renderable/renderable.hh	/^		RenderAble() {}$/;"	f	class:RenderAble	access:public	signature:()
RenderAble::get_trace	include/renderable/renderable.hh	/^		virtual std::shared_ptr<Trace> get_trace(const Ray& ray) const = 0;$/;"	p	class:RenderAble	access:public	signature:(const Ray& ray) const
RenderAble::new_trace	include/renderable/renderable.hh	/^		std::shared_ptr<Trace> new_trace(const Ray& ray);$/;"	p	class:RenderAble	access:public	signature:(const Ray& ray)
RenderAble::visible_to	include/renderable/renderable.hh	/^		virtual bool visible_to(const Ray& ray) const = 0;$/;"	p	class:RenderAble	access:public	signature:(const Ray& ray) const
RenderAble::~RenderAble	include/renderable/renderable.hh	/^		virtual ~RenderAble(){}$/;"	f	class:RenderAble	access:public	signature:()
RenderBase	include/render.hh	/^		RenderBase(const Geometry &m_g):$/;"	f	class:RenderBase	access:public	signature:(const Geometry &m_g)
RenderBase	include/render.hh	/^class RenderBase {$/;"	c
RenderBase::RenderBase	include/render.hh	/^		RenderBase(const Geometry &m_g):$/;"	f	class:RenderBase	access:public	signature:(const Geometry &m_g)
RenderBase::_write	include/render.hh	/^		virtual void _write(int x, int y, const Color &c) = 0;$/;"	p	class:RenderBase	access:protected	signature:(int x, int y, const Color &c)
RenderBase::finish	include/render.hh	/^		virtual void finish() {}$/;"	f	class:RenderBase	access:public	signature:()
RenderBase::geo	include/render.hh	/^		Geometry geo;$/;"	m	class:RenderBase	access:protected
RenderBase::get_cnt	include/render.hh	/^		int get_cnt() const$/;"	f	class:RenderBase	access:public	signature:() const
RenderBase::get_geo	include/render.hh	/^		const Geometry& get_geo() const$/;"	f	class:RenderBase	access:public	signature:() const
RenderBase::init	include/render.hh	/^		virtual void init() {}$/;"	f	class:RenderBase	access:public	signature:()
RenderBase::render_cnt	include/render.hh	/^		int render_cnt = 0;$/;"	m	class:RenderBase	access:private
RenderBase::write	include/render.hh	/^		void write(Matrix<Color>& m) {$/;"	f	class:RenderBase	access:public	signature:(Matrix<Color>& m)
RenderBase::write	include/render.hh	/^		void write(int x, int y, const Color &c) {$/;"	f	class:RenderBase	access:public	signature:(int x, int y, const Color &c)
RenderBase::~RenderBase	include/render.hh	/^		virtual ~RenderBase(){};$/;"	f	class:RenderBase	access:public	signature:()
SHELL	Makefile	/^SHELL = bash$/;"	m
TARGET	Makefile	/^TARGET = main$/;"	m
TERM_COLOR	utils.cc	/^string TERM_COLOR(int k) {$/;"	f	signature:(int k)
Trace	include/renderable/renderable.hh	/^		Trace(const RenderAble& m_obj, const Ray& m_ray):$/;"	f	class:Trace	access:public	signature:(const RenderAble& m_obj, const Ray& m_ray)
Trace	include/renderable/renderable.hh	/^		Trace(const Trace&) = delete;$/;"	p	class:Trace	access:public	signature:(const Trace&)
Trace	include/renderable/renderable.hh	/^class Trace {$/;"	c
Trace::Trace	include/renderable/renderable.hh	/^		Trace(const RenderAble& m_obj, const Ray& m_ray):$/;"	f	class:Trace	access:public	signature:(const RenderAble& m_obj, const Ray& m_ray)
Trace::Trace	include/renderable/renderable.hh	/^		Trace(const Trace&) = delete;$/;"	p	class:Trace	access:public	signature:(const Trace&)
Trace::get_obj	include/renderable/renderable.hh	/^		const RenderAble& get_obj()$/;"	f	class:Trace	access:public	signature:()
Trace::intersection_dist	include/renderable/renderable.hh	/^		virtual real_t intersection_dist() = 0;$/;"	p	class:Trace	access:public	signature:()
Trace::normal	include/renderable/renderable.hh	/^		virtual Vec normal() = 0;$/;"	p	class:Trace	access:public	signature:()
Trace::obj	include/renderable/renderable.hh	/^		const RenderAble& obj;$/;"	m	class:Trace	access:protected
Trace::operator =	include/renderable/renderable.hh	/^		Trace& operator = (const Trace&) = delete;$/;"	p	class:Trace	access:public	signature:(const Trace&)
Trace::ray	include/renderable/renderable.hh	/^		const Ray& ray;$/;"	m	class:Trace	access:protected
Trace::~Trace	include/renderable/renderable.hh	/^		virtual ~Trace(){ }$/;"	f	class:Trace	access:public	signature:()
UPDATE	include/geometry/aabb.hh	57;"	d
UPDATE	include/geometry/aabb.hh	69;"	d
Vec	include/geometry/geometry.hh	/^typedef Vector Vec;$/;"	t
Vector	include/geometry/geometry.hh	/^		Vector(const Vector &p0, const Vector &p1):$/;"	f	class:Vector	access:public	signature:(const Vector &p0, const Vector &p1)
Vector	include/geometry/geometry.hh	/^		explicit Vector(real_t m_x = 0, real_t m_y = 0, real_t m_z = 0):$/;"	f	class:Vector	access:public	signature:(real_t m_x = 0, real_t m_y = 0, real_t m_z = 0)
Vector	include/geometry/geometry.hh	/^class Vector {$/;"	c
Vector2D	include/geometry/geometry.hh	/^		Vector2D<T> (const Vector2D<T> &p0, const Vector2D<T> &p1):$/;"	f	class:Vector2D	access:public	signature:(const Vector2D<T> &p0, const Vector2D<T> &p1)
Vector2D	include/geometry/geometry.hh	/^		Vector2D<T>(){};$/;"	f	class:Vector2D	access:public	signature:()
Vector2D	include/geometry/geometry.hh	/^		explicit Vector2D<T>(T m_x, T m_y):$/;"	f	class:Vector2D	access:public	signature:(T m_x, T m_y)
Vector2D	include/geometry/geometry.hh	/^class Vector2D {$/;"	c
Vector2D::Vector2D	include/geometry/geometry.hh	/^		Vector2D<T> (const Vector2D<T> &p0, const Vector2D<T> &p1):$/;"	f	class:Vector2D	access:public	signature:(const Vector2D<T> &p0, const Vector2D<T> &p1)
Vector2D::Vector2D	include/geometry/geometry.hh	/^		Vector2D<T>(){};$/;"	f	class:Vector2D	access:public	signature:()
Vector2D::Vector2D	include/geometry/geometry.hh	/^		explicit Vector2D<T>(T m_x, T m_y):$/;"	f	class:Vector2D	access:public	signature:(T m_x, T m_y)
Vector2D::cross	include/geometry/geometry.hh	/^		T cross(const Vector2D<T> &v) const$/;"	f	class:Vector2D	access:public	signature:(const Vector2D<T> &v) const
Vector2D::dot	include/geometry/geometry.hh	/^		T dot(const Vector2D<T> &v) const$/;"	f	class:Vector2D	access:public	signature:(const Vector2D<T> &v) const
Vector2D::get_normalized	include/geometry/geometry.hh	/^		Vector2D<T> get_normalized() const$/;"	f	class:Vector2D	access:public	signature:() const
Vector2D::is_zero	include/geometry/geometry.hh	/^		bool is_zero() const$/;"	f	class:Vector2D	access:public	signature:() const
Vector2D::mod	include/geometry/geometry.hh	/^		real_t mod() const$/;"	f	class:Vector2D	access:public	signature:() const
Vector2D::operator !	include/geometry/geometry.hh	/^		Vector2D<T> operator ! () const$/;"	f	class:Vector2D	access:public	signature:() const
Vector2D::operator *	include/geometry/geometry.hh	/^		Vector2D<T> operator * (real_t f) const$/;"	f	class:Vector2D	access:public	signature:(real_t f) const
Vector2D::operator +	include/geometry/geometry.hh	/^		Vector2D<T> operator + (const Vector2D<T> &v) const$/;"	f	class:Vector2D	access:public	signature:(const Vector2D<T> &v) const
Vector2D::operator +=	include/geometry/geometry.hh	/^		Vector2D<T>& operator += (const Vector2D<T> &v)$/;"	f	class:Vector2D	access:public	signature:(const Vector2D<T> &v)
Vector2D::operator -	include/geometry/geometry.hh	/^		Vector2D<T> operator - (const Vector2D<T> &v) const$/;"	f	class:Vector2D	access:public	signature:(const Vector2D<T> &v) const
Vector2D::operator -=	include/geometry/geometry.hh	/^		Vector2D<T>& operator -= (const Vector2D<T> &v)$/;"	f	class:Vector2D	access:public	signature:(const Vector2D<T> &v)
Vector2D::operator /	include/geometry/geometry.hh	/^		Vector2D<T> operator \/ (real_t f) const$/;"	f	class:Vector2D	access:public	signature:(real_t f) const
Vector2D::operator <<	include/geometry/geometry.hh	/^		friend std::ostream& operator << (std::ostream& os, const Vector2D<TT>& v);$/;"	p	class:Vector2D	access:friend	signature:(std::ostream& os, const Vector2D<TT>& v)
Vector2D::operator ==	include/geometry/geometry.hh	/^		bool operator == (const Vector2D<T> &v) const$/;"	f	class:Vector2D	access:public	signature:(const Vector2D<T> &v) const
Vector2D::operator ~	include/geometry/geometry.hh	/^		Vector2D<T> operator ~ () const$/;"	f	class:Vector2D	access:public	signature:() const
Vector2D::sqr	include/geometry/geometry.hh	/^		T sqr() const$/;"	f	class:Vector2D	access:public	signature:() const
Vector2D::update_max	include/geometry/geometry.hh	/^		void update_max(const Vector2D<T> &v)$/;"	f	class:Vector2D	access:public	signature:(const Vector2D<T> &v)
Vector2D::update_min	include/geometry/geometry.hh	/^		void update_min(const Vector2D<T> &v)$/;"	f	class:Vector2D	access:public	signature:(const Vector2D<T> &v)
Vector2D::x	include/geometry/geometry.hh	/^		T x = 0, y = 0;$/;"	m	class:Vector2D	access:public
Vector2D::y	include/geometry/geometry.hh	/^		T x = 0, y = 0;$/;"	m	class:Vector2D	access:public
Vector::Vector	include/geometry/geometry.hh	/^		Vector(const Vector &p0, const Vector &p1):$/;"	f	class:Vector	access:public	signature:(const Vector &p0, const Vector &p1)
Vector::Vector	include/geometry/geometry.hh	/^		explicit Vector(real_t m_x = 0, real_t m_y = 0, real_t m_z = 0):$/;"	f	class:Vector	access:public	signature:(real_t m_x = 0, real_t m_y = 0, real_t m_z = 0)
Vector::cross	include/geometry/geometry.hh	/^		Vector cross(const Vector &v) const$/;"	f	class:Vector	access:public	signature:(const Vector &v) const
Vector::dot	include/geometry/geometry.hh	/^		real_t dot(const Vector &v) const$/;"	f	class:Vector	access:public	signature:(const Vector &v) const
Vector::get_max	include/geometry/geometry.hh	/^		static Vector get_max()$/;"	f	class:Vector	access:public	signature:()
Vector::get_normalized	include/geometry/geometry.hh	/^		Vector get_normalized() const$/;"	f	class:Vector	access:public	signature:() const
Vector::get_zero	include/geometry/geometry.hh	/^		static Vector get_zero()$/;"	f	class:Vector	access:public	signature:()
Vector::index	include/geometry/geometry.hh	/^		real_t index(int c) const$/;"	f	class:Vector	access:public	signature:(int c) const
Vector::index	include/geometry/geometry.hh	/^		real_t& index(int c)$/;"	f	class:Vector	access:public	signature:(int c)
Vector::is_positive	include/geometry/geometry.hh	/^		bool is_positive(real_t threshold = EPS) const$/;"	f	class:Vector	access:public	signature:(real_t threshold = EPS) const
Vector::is_zero	include/geometry/geometry.hh	/^		bool is_zero(real_t threshold = EPS) const$/;"	f	class:Vector	access:public	signature:(real_t threshold = EPS) const
Vector::min_comp_abs	include/geometry/geometry.hh	/^		real_t min_comp_abs() const {$/;"	f	class:Vector	access:public	signature:() const
Vector::mod	include/geometry/geometry.hh	/^		real_t mod() const$/;"	f	class:Vector	access:public	signature:() const
Vector::normalize	include/geometry/geometry.hh	/^		void normalize() {$/;"	f	class:Vector	access:public	signature:()
Vector::operator !=	include/geometry/geometry.hh	/^		bool operator != (const Vector &v) const$/;"	f	class:Vector	access:public	signature:(const Vector &v) const
Vector::operator *	include/geometry/geometry.hh	/^		Vector operator * (real_t p) const$/;"	f	class:Vector	access:public	signature:(real_t p) const
Vector::operator *=	include/geometry/geometry.hh	/^		Vector& operator *= (real_t p)$/;"	f	class:Vector	access:public	signature:(real_t p)
Vector::operator +	include/geometry/geometry.hh	/^		Vector operator + (const Vector &v) const$/;"	f	class:Vector	access:public	signature:(const Vector &v) const
Vector::operator +=	include/geometry/geometry.hh	/^		Vector& operator += (const Vector &v)$/;"	f	class:Vector	access:public	signature:(const Vector &v)
Vector::operator -	include/geometry/geometry.hh	/^		Vector operator - () const$/;"	f	class:Vector	access:public	signature:() const
Vector::operator -	include/geometry/geometry.hh	/^		Vector operator - (const Vector &v) const$/;"	f	class:Vector	access:public	signature:(const Vector &v) const
Vector::operator -=	include/geometry/geometry.hh	/^		Vector& operator -= (const Vector &v)$/;"	f	class:Vector	access:public	signature:(const Vector &v)
Vector::operator /	include/geometry/geometry.hh	/^		Vector operator \/ (real_t p) const$/;"	f	class:Vector	access:public	signature:(real_t p) const
Vector::operator <<	include/geometry/geometry.hh	/^		friend std::ostream & operator << (std::ostream &os, const Vector& vec)$/;"	f	class:Vector	access:friend	signature:(std::ostream &os, const Vector& vec)
Vector::operator ==	include/geometry/geometry.hh	/^		bool operator == (const Vector &v) const$/;"	f	class:Vector	access:public	signature:(const Vector &v) const
Vector::sqr	include/geometry/geometry.hh	/^		real_t sqr() const$/;"	f	class:Vector	access:public	signature:() const
Vector::update_max	include/geometry/geometry.hh	/^		void update_max(const Vector &v)$/;"	f	class:Vector	access:public	signature:(const Vector &v)
Vector::update_min	include/geometry/geometry.hh	/^		void update_min(const Vector &v)$/;"	f	class:Vector	access:public	signature:(const Vector &v)
Vector::x	include/geometry/geometry.hh	/^		real_t x = 0, y = 0, z = 0;$/;"	m	class:Vector	access:public
Vector::y	include/geometry/geometry.hh	/^		real_t x = 0, y = 0, z = 0;$/;"	m	class:Vector	access:public
Vector::z	include/geometry/geometry.hh	/^		real_t x = 0, y = 0, z = 0;$/;"	m	class:Vector	access:public
WHITE	include/color.hh	/^		static const Color WHITE, BLACK;$/;"	m	class:Color	access:public
__HEAD__AABB	include/geometry/aabb.hh	6;"	d
__HEAD__COLOR	include/color.hh	6;"	d
__HEAD__COMMON	include/common.hh	6;"	d
__HEAD__DEBUGUTILS	include/debugutils.hh	6;"	d
__HEAD__GEOMETRY	include/geometry/geometry.hh	6;"	d
__HEAD__LIGHT	include/renderable/light.hh	6;"	d
__HEAD__MATRIX	include/matrix.hh	6;"	d
__HEAD__MATRIX_RENDER	include/matrixrender.hh	6;"	d
__HEAD__OPENCV_RENDER	include/opencv.hh	6;"	d
__HEAD__PICTURE	include/picture.hh	6;"	d
__HEAD__PLANE	include/geometry/plane.hh	6;"	d
__HEAD__PLANE	include/renderable/plane.hh	6;"	d
__HEAD__RAY	include/geometry/ray.hh	6;"	d
__HEAD__RENDER	include/render.hh	6;"	d
__HEAD__RENDERABLE	include/renderable/renderable.hh	6;"	d
__HEAD__UTILS	include/utils.hh	6;"	d
__m_assert_check__	debugutils.cc	/^void __m_assert_check__(bool val, const char *expr, const char *file, const char *func, int line) {$/;"	f	signature:(bool val, const char *expr, const char *file, const char *func, int line)
__m_assert_check__	include/debugutils.hh	/^void __m_assert_check__(bool val, const char *expr,$/;"	p	signature:(bool val, const char *expr, const char *file, const char *func, int line)
__print_debug__	debugutils.cc	/^void __print_debug__(const char *file, const char *func, int line, const char *fmt, ...) {$/;"	f	signature:(const char *file, const char *func, int line, const char *fmt, ...)
__print_debug__	include/debugutils.hh	/^void __print_debug__(const char *file, const char *func, int line, const char *fmt, ...)$/;"	p	signature:(const char *file, const char *func, int line, const char *fmt, ...)
_write	include/matrixrender.hh	/^		void _write(int x, int y, const Color &c)$/;"	f	class:MatrixRender	access:public	signature:(int x, int y, const Color &c)
_write	include/opencv.hh	/^		void _write(int x, int y, const Color& c);$/;"	p	class:CVRender	access:protected	signature:(int x, int y, const Color& c)
_write	include/render.hh	/^		virtual void _write(int x, int y, const Color &c) = 0;$/;"	p	class:RenderBase	access:protected	signature:(int x, int y, const Color &c)
_write	opencv.cc	/^void CVRender::_write(int x, int y, const Color& c) {$/;"	f	class:CVRender	signature:(int x, int y, const Color& c)
add_light	include/picture.hh	/^		void add_light(const Light& light)$/;"	f	class:Picture	access:public	signature:(const Light& light)
add_obj	include/picture.hh	/^		void add_obj(const std::shared_ptr<RenderAble>& objptr)$/;"	f	class:Picture	access:public	signature:(const std::shared_ptr<RenderAble>& objptr)
ambient	include/picture.hh	/^		Color ambient;$/;"	m	class:Picture	access:private
area	include/render.hh	/^		inline int area() const {$/;"	f	class:Geometry	access:public	signature:() const
black	include/color.hh	/^		bool black() const$/;"	f	class:Color	access:public	signature:() const
c_fprintf	include/utils.hh	/^void c_fprintf(const char* col, FILE* fp, const char* fmt, ...);$/;"	p	signature:(const char* col, FILE* fp, const char* fmt, ...)
c_fprintf	utils.cc	/^void c_fprintf(const char* col, FILE* fp, const char* fmt, ...) {$/;"	f	signature:(const char* col, FILE* fp, const char* fmt, ...)
c_printf	include/utils.hh	/^void c_printf(const char* col, const char* fmt, ...);$/;"	p	signature:(const char* col, const char* fmt, ...)
c_printf	utils.cc	/^void c_printf(const char* col, const char* fmt, ...) {$/;"	f	signature:(const char* col, const char* fmt, ...)
ccSOURCES	Makefile	/^ccSOURCES = $(shell find -name "*.cc" | sed 's\/^\\.\\\/\/\/g')$/;"	m
check	include/color.hh	/^		void check() const {$/;"	f	class:Color	access:public	signature:() const
color	include/renderable/light.hh	/^		Color color;$/;"	m	class:Light	access:public
contain	include/geometry/aabb.hh	/^		bool contain(const Vec& p) const$/;"	f	class:AABB	access:public	signature:(const Vec& p) const
contain	include/render.hh	/^		inline bool contain(int x, int y)$/;"	f	class:Geometry	access:public	signature:(int x, int y)
cross	include/geometry/geometry.hh	/^		T cross(const Vector2D<T> &v) const$/;"	f	class:Vector2D	access:public	signature:(const Vector2D<T> &v) const
cross	include/geometry/geometry.hh	/^		Vector cross(const Vector &v) const$/;"	f	class:Vector	access:public	signature:(const Vector &v) const
dir	include/geometry/ray.hh	/^		Vec orig, dir;$/;"	m	class:Ray	access:public
dist	include/geometry/plane.hh	/^		real_t dist(const Vec& p)$/;"	f	class:Plane	access:public	signature:(const Vec& p)
dist	include/geometry/plane.hh	/^		real_t dist;$/;"	m	class:Plane	access:private
distance	include/geometry/ray.hh	/^		real_t distance(const Vec& p) const$/;"	f	class:Ray	access:public	signature:(const Vec& p) const
dot	include/geometry/geometry.hh	/^		T dot(const Vector2D<T> &v) const$/;"	f	class:Vector2D	access:public	signature:(const Vector2D<T> &v) const
dot	include/geometry/geometry.hh	/^		real_t dot(const Vector &v) const$/;"	f	class:Vector	access:public	signature:(const Vector &v) const
empty	include/geometry/aabb.hh	/^		bool empty()$/;"	f	class:AABB	access:public	signature:()
error_exit	debugutils.cc	/^void error_exit(const char *msg) {$/;"	f	signature:(const char *msg)
error_exit	include/debugutils.hh	/^void error_exit(const char *msg) __attribute__((noreturn));$/;"	p	signature:(const char *msg)
find_first	include/picture.hh	/^		std::shared_ptr<Trace> find_first(const Ray& ray) const;$/;"	p	class:Picture	access:protected	signature:(const Ray& ray) const
find_first	picture.cc	/^std::shared_ptr<Trace> Picture::find_first(const Ray& ray) const {$/;"	f	class:Picture	signature:(const Ray& ray) const
finish	include/opencv.hh	/^		void finish();$/;"	p	class:CVRender	access:public	signature:()
finish	include/render.hh	/^		virtual void finish() {}$/;"	f	class:RenderBase	access:public	signature:()
finish	opencv.cc	/^void CVRender::finish() {$/;"	f	class:CVRender	signature:()
geo	include/render.hh	/^		Geometry geo;$/;"	m	class:RenderBase	access:protected
get	include/matrixrender.hh	/^		Color& get(int x, int y)$/;"	f	class:MatrixRender	access:public	signature:(int x, int y)
get_cnt	include/render.hh	/^		int get_cnt() const$/;"	f	class:RenderBase	access:public	signature:() const
get_dist	include/geometry/ray.hh	/^		Vec get_dist(real_t d) const$/;"	f	class:Ray	access:public	signature:(real_t d) const
get_geo	include/render.hh	/^		const Geometry& get_geo() const$/;"	f	class:RenderBase	access:public	signature:() const
get_max	include/geometry/geometry.hh	/^		static Vector get_max()$/;"	f	class:Vector	access:public	signature:()
get_normalized	include/geometry/geometry.hh	/^		Vector get_normalized() const$/;"	f	class:Vector	access:public	signature:() const
get_normalized	include/geometry/geometry.hh	/^		Vector2D<T> get_normalized() const$/;"	f	class:Vector2D	access:public	signature:() const
get_obj	include/renderable/renderable.hh	/^		const RenderAble& get_obj()$/;"	f	class:Trace	access:public	signature:()
get_trace	include/renderable/light.hh	/^		std::shared_ptr<Trace> get_trace(const Ray& ray) const {$/;"	f	class:Light	access:public	signature:(const Ray& ray) const
get_trace	include/renderable/renderable.hh	/^		virtual std::shared_ptr<Trace> get_trace(const Ray& ray) const = 0;$/;"	p	class:RenderAble	access:public	signature:(const Ray& ray) const
get_zero	include/geometry/geometry.hh	/^		static Vector get_zero()$/;"	f	class:Vector	access:public	signature:()
h	include/matrix.hh	/^		int w, h;$/;"	m	class:Matrix	access:public
h	include/render.hh	/^		int w, h;$/;"	m	class:Geometry	access:public
img	include/opencv.hh	/^	cv::Mat img;$/;"	m	class:CVRender	access:private
in_half_space	include/geometry/plane.hh	/^		bool in_half_space(const Vec& p)$/;"	f	class:Plane	access:public	signature:(const Vec& p)
in_plane	include/geometry/plane.hh	/^		bool in_plane(const Vec& p)$/;"	f	class:Plane	access:public	signature:(const Vec& p)
index	include/geometry/geometry.hh	/^		real_t index(int c) const$/;"	f	class:Vector	access:public	signature:(int c) const
index	include/geometry/geometry.hh	/^		real_t& index(int c)$/;"	f	class:Vector	access:public	signature:(int c)
init	include/picture.hh	/^		void init();$/;"	p	class:Picture	access:public	signature:()
init	include/render.hh	/^		virtual void init() {}$/;"	f	class:RenderBase	access:public	signature:()
init	picture.cc	/^void Picture::init() {$/;"	f	class:Picture	signature:()
intensity	include/renderable/light.hh	/^		real_t intensity;$/;"	m	class:Light	access:public
intersect	include/geometry/aabb.hh	/^		bool intersect(const Ray& ray, real_t &mind, real_t &maxd) {$/;"	f	class:AABB	access:public	signature:(const Ray& ray, real_t &mind, real_t &maxd)
intersection_dist	include/renderable/light.hh	/^		real_t intersection_dist()$/;"	f	class:LightTrace	access:public	signature:()
intersection_dist	include/renderable/renderable.hh	/^		virtual real_t intersection_dist() = 0;$/;"	p	class:Trace	access:public	signature:()
is_positive	include/geometry/geometry.hh	/^		bool is_positive(real_t threshold = EPS) const$/;"	f	class:Vector	access:public	signature:(real_t threshold = EPS) const
is_zero	include/geometry/geometry.hh	/^		bool is_zero() const$/;"	f	class:Vector2D	access:public	signature:() const
is_zero	include/geometry/geometry.hh	/^		bool is_zero(real_t threshold = EPS) const$/;"	f	class:Vector	access:public	signature:(real_t threshold = EPS) const
light	include/renderable/light.hh	/^		const Light& light;$/;"	m	class:LightTrace	access:private
lights	include/picture.hh	/^		std::vector<std::shared_ptr<Light>>  lights;$/;"	m	class:Picture	access:private
m_assert	include/debugutils.hh	13;"	d
main	main.cc	/^int main(int argc, char* argv[]) {$/;"	f	signature:(int argc, char* argv[])
mat	include/matrixrender.hh	/^		Matrix<Color>* mat;$/;"	m	class:MatrixRender	access:public
max	include/geometry/aabb.hh	/^			max = -Vec::max();$/;"	m	class:AABB	access:private
min	include/geometry/aabb.hh	/^		Vec min = Vec::max(),$/;"	m	class:AABB	access:private
min_comp_abs	include/geometry/geometry.hh	/^		real_t min_comp_abs() const {$/;"	f	class:Vector	access:public	signature:() const
mod	include/geometry/geometry.hh	/^		real_t mod() const$/;"	f	class:Vector	access:public	signature:() const
mod	include/geometry/geometry.hh	/^		real_t mod() const$/;"	f	class:Vector2D	access:public	signature:() const
new_trace	include/renderable/renderable.hh	/^		std::shared_ptr<Trace> new_trace(const Ray& ray);$/;"	p	class:RenderAble	access:public	signature:(const Ray& ray)
norm	include/geometry/plane.hh	/^		Vec norm;$/;"	m	class:Plane	access:private
normal	include/renderable/light.hh	/^		Vec normal()$/;"	f	class:LightTrace	access:public	signature:()
normal	include/renderable/renderable.hh	/^		virtual Vec normal() = 0;$/;"	p	class:Trace	access:public	signature:()
normalize	include/geometry/geometry.hh	/^		void normalize() {$/;"	f	class:Vector	access:public	signature:()
now_max_depth	include/picture.hh	/^		int now_max_depth;$/;"	m	class:Picture	access:private
now_ray_count	include/picture.hh	/^		int now_ray_count;$/;"	m	class:Picture	access:private
obj	include/renderable/renderable.hh	/^		const RenderAble& obj;$/;"	m	class:Trace	access:protected
objs	include/picture.hh	/^		std::vector<std::shared_ptr<RenderAble>> objs;$/;"	m	class:Picture	access:private
operator !	include/geometry/geometry.hh	/^		Vector2D<T> operator ! () const$/;"	f	class:Vector2D	access:public	signature:() const
operator !=	include/geometry/geometry.hh	/^		bool operator != (const Vector &v) const$/;"	f	class:Vector	access:public	signature:(const Vector &v) const
operator *	include/geometry/geometry.hh	/^		Vector operator * (real_t p) const$/;"	f	class:Vector	access:public	signature:(real_t p) const
operator *	include/geometry/geometry.hh	/^		Vector2D<T> operator * (real_t f) const$/;"	f	class:Vector2D	access:public	signature:(real_t f) const
operator *=	include/geometry/geometry.hh	/^		Vector& operator *= (real_t p)$/;"	f	class:Vector	access:public	signature:(real_t p)
operator +	include/geometry/geometry.hh	/^		Vector operator + (const Vector &v) const$/;"	f	class:Vector	access:public	signature:(const Vector &v) const
operator +	include/geometry/geometry.hh	/^		Vector2D<T> operator + (const Vector2D<T> &v) const$/;"	f	class:Vector2D	access:public	signature:(const Vector2D<T> &v) const
operator +=	include/geometry/geometry.hh	/^		Vector& operator += (const Vector &v)$/;"	f	class:Vector	access:public	signature:(const Vector &v)
operator +=	include/geometry/geometry.hh	/^		Vector2D<T>& operator += (const Vector2D<T> &v)$/;"	f	class:Vector2D	access:public	signature:(const Vector2D<T> &v)
operator -	include/geometry/geometry.hh	/^		Vector operator - () const$/;"	f	class:Vector	access:public	signature:() const
operator -	include/geometry/geometry.hh	/^		Vector operator - (const Vector &v) const$/;"	f	class:Vector	access:public	signature:(const Vector &v) const
operator -	include/geometry/geometry.hh	/^		Vector2D<T> operator - (const Vector2D<T> &v) const$/;"	f	class:Vector2D	access:public	signature:(const Vector2D<T> &v) const
operator -=	include/geometry/geometry.hh	/^		Vector& operator -= (const Vector &v)$/;"	f	class:Vector	access:public	signature:(const Vector &v)
operator -=	include/geometry/geometry.hh	/^		Vector2D<T>& operator -= (const Vector2D<T> &v)$/;"	f	class:Vector2D	access:public	signature:(const Vector2D<T> &v)
operator /	include/geometry/geometry.hh	/^		Vector operator \/ (real_t p) const$/;"	f	class:Vector	access:public	signature:(real_t p) const
operator /	include/geometry/geometry.hh	/^		Vector2D<T> operator \/ (real_t f) const$/;"	f	class:Vector2D	access:public	signature:(real_t f) const
operator <<	include/geometry/geometry.hh	/^		friend std::ostream & operator << (std::ostream &os, const Vector& vec)$/;"	f	class:Vector	access:friend	signature:(std::ostream &os, const Vector& vec)
operator <<	include/geometry/geometry.hh	/^		friend std::ostream& operator << (std::ostream& os, const Vector2D<TT>& v);$/;"	p	class:Vector2D	access:friend	signature:(std::ostream& os, const Vector2D<TT>& v)
operator <<	include/geometry/geometry.hh	/^std::ostream& operator << (std::ostream& os, const Vector2D<T>& v) {$/;"	f	signature:(std::ostream& os, const Vector2D<T>& v)
operator =	include/matrix.hh	/^		Matrix & operator = (const Matrix &) = delete;$/;"	p	class:Matrix	access:public	signature:(const Matrix &)
operator =	include/renderable/renderable.hh	/^		Trace& operator = (const Trace&) = delete;$/;"	p	class:Trace	access:public	signature:(const Trace&)
operator ==	include/geometry/geometry.hh	/^		bool operator == (const Vector &v) const$/;"	f	class:Vector	access:public	signature:(const Vector &v) const
operator ==	include/geometry/geometry.hh	/^		bool operator == (const Vector2D<T> &v) const$/;"	f	class:Vector2D	access:public	signature:(const Vector2D<T> &v) const
operator []	include/matrix.hh	/^		T*& operator [] (int i) {$/;"	f	class:Matrix	access:public	signature:(int i)
operator ~	include/geometry/geometry.hh	/^		Vector2D<T> operator ~ () const$/;"	f	class:Vector2D	access:public	signature:() const
orig	include/geometry/ray.hh	/^		Vec orig, dir;$/;"	m	class:Ray	access:public
parallel	include/geometry/plane.hh	/^		bool parallel(const Ray& ray)$/;"	f	class:Plane	access:public	signature:(const Ray& ray)
plane	include/renderable/plane.hh	/^		Plane plane;$/;"	m	class:PlaneObj	access:private
print_debug	include/debugutils.hh	21;"	d
print_debug	include/debugutils.hh	30;"	d
project	include/geometry/ray.hh	/^		Vec project(const Vec& p) const {$/;"	f	class:Ray	access:public	signature:(const Vec& p) const
ratio	include/render.hh	/^		real_t ratio() const {$/;"	f	class:Geometry	access:public	signature:() const
ray	include/renderable/renderable.hh	/^		const Ray& ray;$/;"	m	class:Trace	access:protected
real_t	include/common.hh	/^typedef double real_t;$/;"	t
render_cnt	include/render.hh	/^		int render_cnt = 0;$/;"	m	class:RenderBase	access:private
set	include/geometry/aabb.hh	/^		void set(const Vec& vmin, const Vec& vmax)$/;"	f	class:AABB	access:public	signature:(const Vec& vmin, const Vec& vmax)
sign	include/common.hh	/^static inline int sign(real_t x) {$/;"	f	signature:(real_t x)
size	include/geometry/aabb.hh	/^		Vec size() const$/;"	f	class:AABB	access:public	signature:() const
size	include/renderable/light.hh	/^		real_t size = EPS;$/;"	m	class:Light	access:public
sqr	include/geometry/geometry.hh	/^		T sqr() const$/;"	f	class:Vector2D	access:public	signature:() const
sqr	include/geometry/geometry.hh	/^		real_t sqr() const$/;"	f	class:Vector	access:public	signature:() const
sqrdistance	include/geometry/ray.hh	/^		real_t sqrdistance(const Vec& p) const$/;"	f	class:Ray	access:public	signature:(const Vec& p) const
src	include/renderable/light.hh	/^		Vec src;$/;"	m	class:Light	access:public
trace	include/picture.hh	/^		Color trace(const Ray& ray, real_t weight = 1, int depth = 0);$/;"	p	class:Picture	access:public	signature:(const Ray& ray, real_t weight = 1, int depth = 0)
trace	picture.cc	/^Color Picture::trace(const Ray& ray, real_t weight, int depth) {$/;"	f	class:Picture	signature:(const Ray& ray, real_t weight, int depth)
update	include/geometry/aabb.hh	/^		void update(const AABB& b) {$/;"	f	class:AABB	access:public	signature:(const AABB& b)
update	include/geometry/aabb.hh	/^		void update(const Vec& v) {$/;"	f	class:AABB	access:public	signature:(const Vec& v)
update_max	include/common.hh	/^bool update_max(T &dest, const T &val) {$/;"	f	signature:(T &dest, const T &val)
update_max	include/geometry/geometry.hh	/^		void update_max(const Vector &v)$/;"	f	class:Vector	access:public	signature:(const Vector &v)
update_max	include/geometry/geometry.hh	/^		void update_max(const Vector2D<T> &v)$/;"	f	class:Vector2D	access:public	signature:(const Vector2D<T> &v)
update_min	include/common.hh	/^bool update_min(T &dest, const T &val) {$/;"	f	signature:(T &dest, const T &val)
update_min	include/geometry/geometry.hh	/^		void update_min(const Vector &v)$/;"	f	class:Vector	access:public	signature:(const Vector &v)
update_min	include/geometry/geometry.hh	/^		void update_min(const Vector2D<T> &v)$/;"	f	class:Vector2D	access:public	signature:(const Vector2D<T> &v)
val	include/matrix.hh	/^		T **val;$/;"	m	class:Matrix	access:public
visible_to	include/renderable/light.hh	/^		bool visible_to(const Ray& ray) const$/;"	f	class:Light	access:public	signature:(const Ray& ray) const
visible_to	include/renderable/plane.hh	/^		bool visible_to(const Ray& ray)$/;"	f	class:PlaneObj	access:public	signature:(const Ray& ray)
visible_to	include/renderable/renderable.hh	/^		virtual bool visible_to(const Ray& ray) const = 0;$/;"	p	class:RenderAble	access:public	signature:(const Ray& ray) const
w	include/matrix.hh	/^		int w, h;$/;"	m	class:Matrix	access:public
w	include/render.hh	/^		int w, h;$/;"	m	class:Geometry	access:public
weight_threshold	include/picture.hh	/^		real_t weight_threshold = DEFAULT_TRACING_WEIGHT_THRESHOLD;$/;"	m	class:Picture	access:public
write	include/render.hh	/^		void write(Matrix<Color>& m) {$/;"	f	class:RenderBase	access:public	signature:(Matrix<Color>& m)
write	include/render.hh	/^		void write(int x, int y, const Color &c) {$/;"	f	class:RenderBase	access:public	signature:(int x, int y, const Color &c)
x	include/geometry/geometry.hh	/^		T x = 0, y = 0;$/;"	m	class:Vector2D	access:public
x	include/geometry/geometry.hh	/^		real_t x = 0, y = 0, z = 0;$/;"	m	class:Vector	access:public
y	include/geometry/geometry.hh	/^		T x = 0, y = 0;$/;"	m	class:Vector2D	access:public
y	include/geometry/geometry.hh	/^		real_t x = 0, y = 0, z = 0;$/;"	m	class:Vector	access:public
z	include/geometry/geometry.hh	/^		real_t x = 0, y = 0, z = 0;$/;"	m	class:Vector	access:public
~CVRender	include/opencv.hh	/^		~CVRender() {}$/;"	f	class:CVRender	access:public	signature:()
~Matrix	include/matrix.hh	/^		~Matrix() {$/;"	f	class:Matrix	access:public	signature:()
~MatrixRender	include/matrixrender.hh	/^		~MatrixRender()$/;"	f	class:MatrixRender	access:public	signature:()
~Picture	include/picture.hh	/^		~Picture(){}$/;"	f	class:Picture	access:public	signature:()
~Plane	include/geometry/plane.hh	/^		virtual ~Plane(){}$/;"	f	class:Plane	access:public	signature:()
~Ray	include/geometry/ray.hh	/^		virtual ~Ray(){}$/;"	f	class:Ray	access:public	signature:()
~RenderAble	include/renderable/renderable.hh	/^		virtual ~RenderAble(){}$/;"	f	class:RenderAble	access:public	signature:()
~RenderBase	include/render.hh	/^		virtual ~RenderBase(){};$/;"	f	class:RenderBase	access:public	signature:()
~Trace	include/renderable/renderable.hh	/^		virtual ~Trace(){ }$/;"	f	class:Trace	access:public	signature:()
